### 信息安全
***
#### chapter2
##### 1、数据 = 代码
><pre><code>
char buf[] = {
'\xeb',
'\xef'
}
(int（*）（int, int）buf)( 3 , 4 )
</code></pre>
>
**buf**要成为全局变量才能可以执行buf内的指令，局部变量还是会发生段错误.

#### 2、SIGSEGV（段错误）
> 1、原因
>- 1、访问了错误的段
>- 2、错误的访问了段

> 2、权限
>- 代码段：r + x
>- 数据段：r + w
>- 栈   ：r + w + x  (在栈中动态生成一些代码、指令)

> 3、const关键字修饰**全局变量**时，把变量从数据段放到了代码段，所以不可写

> 3、字节对齐
>- 段对齐到物理页大小（4K）
>- 指令对齐到字节

#### 3、最小的hello world
> 1、打印函数
>- 库函数因为位置不确定且容量太大，不能使用，如 e8 offset，因为offset经常变化，所以不能使用。要使用系统调用，因为系统调用在内存中的位置固定。
>（int 80 系统调用软中断, int 3 断点软中断）

> 2、利用Call-Pop技术
<pre><code>
  1          .text
  2         .globl main
  3 main:
  4         call .L
  5         .string "hello\n"
  6 .L:
  7         pop  %ecx
  8         movl $4, %eax
  9         movl $1, %ebx
 11         movl $6, %edx
 12
 13         int $0x80
 14
 15         // write( 1, str, len )
 16         // 4      1   str  5

</code></pre>
>第7行把 **.L** 函数的返回地址（hello字符串的地址）放到ecx寄存器中。这样就可以做到位置无关代码。

#### 4、stdout 与 stderr
> **stdout : 1    stderr : 2**

> 在很多情况下，两者均指向屏幕。在早期计算机中，stdout是连到屏幕上，而stderr是连到打印机上。现在程序中有些时候，stderr是连到某些串口上。

#### 5、金丝雀技术（canary）
函数中有buffer GCC 才会生成canary.
> 1、 栈帧伪造： `canary`放在RET下面，没有保护ebp.具体做法每次只溢出一个字节，改变ebp的值。
><br/> 2、`canary`放在ebp下面，溢出`canary`的一个字节。利用字符串格式化攻击，也可以利用局部变量控制。
><br/> 3、`canary`放在局部变量上面，太晚了，这时候虽然可以检测到，但程序已经执行结束之后了，恶果已经发生了。

#### 6、ROOT-kit（超级用户工具箱）
> 工具箱被改了（ 比如说 cat ls more ），检查密码文件，cat程序将变得不可信。

#### 7、保护措施
> 1、编译：（`canary`）
><br/> 2、操作系统 ：
>- (内存保护)，让ret和ebp变得不可写。基于`页`的权限，让某一页的权限不同。
>- NX: NO X, 让其变得不可执行。（DEP）（在微软中的保护措施，原理一样）(**Return-to-libc**可以破解)
>- GCC: 蹦床代码，动态生成一些代码，放到栈中，这时候就需要栈可执行。
